1. Implementación de Pagos en mi mini app
Objetivo: Facilitar pagos dentro de la mini app utilizando WLD y USDC.e a través de transacciones en la blockchain.

Requisitos:

Implementar el sistema de pagos de World App, permitiendo que los usuarios realicen pagos con WLD y USDC.e.

Mi dirección de wallet es:
0x01a0eea37c87cfaf13efd17674d2af21e5401bb0

El sistema debe consistir en tres pasos sencillos:

Crear la transacción: Generar un ID único para cada pago y almacenarlo en la base de datos.

Enviar el comando de pago: Utilizar el comando Pay de World App para permitir el pago y enviar la transacción.

Verificar el pago: Una vez enviado el pago, verificar la transacción en la blockchain y confirmar que la transacción se ha completado correctamente.

Código de ejemplo para la creación de la transacción (backend):

ts
نسخ
تحرير
import { NextRequest, NextResponse } from 'next/server';

export async function POST(req: NextRequest) {
  const uuid = crypto.randomUUID().replace(/-/g, '');
  // Almacenar el ID en la base de datos para futura verificación
  return NextResponse.json({ id: uuid });
}
Código para el envío del pago (frontend):

ts
نسخ
تحرير
import { MiniKit, tokenToDecimals, Tokens, PayCommandInput } from '@worldcoin/minikit-js';

const sendPayment = async () => {
  const res = await fetch('/api/initiate-payment', { method: 'POST' });
  const { id } = await res.json();

  const payload: PayCommandInput = {
    reference: id,
    to: '0x01a0eea37c87cfaf13efd17674d2af21e5401bb0', // Dirección de mi wallet
    tokens: [
      {
        symbol: Tokens.WLD,
        token_amount: tokenToDecimals(1, Tokens.WLD).toString(),
      },
      {
        symbol: Tokens.USDCE,
        token_amount: tokenToDecimals(3, Tokens.USDCE).toString(),
      },
    ],
    description: 'Pago de ejemplo para minikit',
  };

  if (!MiniKit.isInstalled()) {
    return;
  }

  const { finalPayload } = await MiniKit.commandsAsync.pay(payload);

  if (finalPayload.status === 'success') {
    const res = await fetch(`/api/confirm-payment`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(finalPayload),
    });
    const payment = await res.json();
    if (payment.success) {
      // Pago exitoso
    }
  }
}
Verificación del pago (backend):

ts
نسخ
تحرير
import { NextRequest, NextResponse } from 'next/server';
import { MiniAppPaymentSuccessPayload } from '@worldcoin/minikit-js';

interface IRequestPayload {
  payload: MiniAppPaymentSuccessPayload;
}

export async function POST(req: NextRequest) {
  const { payload } = (await req.json()) as IRequestPayload;
  const reference = getReferenceFromDB(); // Obtener el ID de la base de datos

  if (payload.reference === reference) {
    const response = await fetch(
      `https://developer.worldcoin.org/api/v2/minikit/transaction/${payload.transaction_id}?app_id=${process.env.APP_ID}`,
      {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${process.env.DEV_PORTAL_API_KEY}`,
        },
      }
    );
    const transaction = await response.json();

    if (transaction.reference === reference && transaction.status !== 'failed') {
      return NextResponse.json({ success: true });
    } else {
      return NextResponse.json({ success: false });
    }
  }
}
2. Implementación de Autenticación con Wallet
Objetivo: Autenticar a los usuarios de la mini app utilizando su dirección de wallet (por ejemplo, de Ethereum o Worldcoin), permitiéndonos gestionar sus sesiones y obtener su información de perfil (nombre de usuario, dirección de wallet, etc.).

Requisitos:

Autenticación con Wallet (Ethereum/Worldcoin): Los usuarios deben poder autenticarse usando su wallet y acceder a la mini app sin necesidad de un nombre de usuario o contraseña tradicionales.

Información del Usuario: Necesitamos acceder a la dirección de wallet del usuario, nombre de usuario, foto de perfil y otros permisos relacionados (como notificaciones).

Código para la autenticación con Wallet usando MiniKit:

ts
نسخ
تحرير
import NextAuth from "next-auth";
import { Providers } from "next-auth/providers";

export default NextAuth({
  providers: [
    Providers.Credentials({
      name: "Wallet",
      credentials: {
        address: { label: "Wallet Address", type: "text" }
      },
      authorize: async (credentials) => {
        const user = await MiniKit.getUserByAddress(credentials.address);
        if (user) {
          return user;
        }
        return null;
      }
    })
  ],
  pages: {
    signIn: '/auth/signin',  // Página personalizada de inicio de sesión
  }
});
Funciones útiles de MiniKit:

Obtener usuario por dirección de wallet:

ts
نسخ
تحرير
MiniKit.getUserByAddress(address: string): Promise<User>
Obtener usuario por nombre de usuario:

ts
نسخ
تحرير
MiniKit.getUserByUsername(username: string): Promise<User>
Gestión de sesiones con NextAuth:

Usamos NextAuth para gestionar las sesiones de los usuarios, lo que permite almacenar y mantener la información del usuario durante su navegación en la mini app.

3. Implementación de Verificación de Usuario con World ID
Objetivo: Verificar que el usuario es un humano real antes de acceder a ciertas funcionalidades dentro de la mini app.

Requisitos:

Acciones Incógnitas: Configurar una acción en el Developer Portal para verificar a los usuarios mediante la acción "verify" de World ID, asegurando que los usuarios sean humanos y no bots.

Proceso de Verificación:

Usar el comando Verify para enviar la solicitud de verificación a World App.

Al recibir la respuesta de verificación, debe ser validada en el backend para asegurar que es legítima.

Código para la verificación en el frontend:

ts
نسخ
تحرير
import { MiniKit, VerifyCommandInput, VerificationLevel, ISuccessResult } from '@worldcoin/minikit-js';

const verifyPayload: VerifyCommandInput = {
  action: 'voting-action', // Este es tu ID de acción desde el Developer Portal
  signal: '0x12312', // Datos adicionales opcionales
  verification_level: VerificationLevel.Orb, // Niveles de verificación: Orb | Device
}

const handleVerify = async () => {
  if (!MiniKit.isInstalled()) {
    return;
  }

  // World App abrirá una ventana emergente pidiendo la confirmación del usuario
  const { finalPayload } = await MiniKit.commandsAsync.verify(verifyPayload);
  if (finalPayload.status === 'error') {
    return console.log('Error payload', finalPayload);
  }

  // Verificar la prueba en el backend
  const verifyResponse = await fetch('/api/verify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      payload: finalPayload as ISuccessResult,
      action: 'voting-action',
      signal: '0x12312', // Opcional
    }),
  });

  // TODO: Manejar el éxito
  const verifyResponseJson = await verifyResponse.json();
  if (verifyResponseJson.status === 200) {
    console.log('¡Verificación exitosa!');
  }
}
Código para la verificación en el backend:

ts
نسخ
تحرير
import { NextRequest, NextResponse } from 'next/server';
import { verifyCloudProof, IVerifyResponse, ISuccessResult } from '@worldcoin/minikit-js';

interface IRequestPayload {
  payload: ISuccessResult;
  action: string;
  signal: string | undefined;
}

export async function POST(req: NextRequest) {
  const { payload, action, signal } = (await req.json()) as IRequestPayload;
  const app_id = process.env.APP_ID as `app_${string}`;
  const verifyRes = (await verifyCloudProof(payload, app_id, action, signal)) as IVerifyResponse;

  if (verifyRes.success) {
    // Realizar acciones si la verificación es exitosa
    return NextResponse.json({ verifyRes, status: 200 });
  } else {
    // Manejar errores de verificación
    return NextResponse.json({ verifyRes, status: 400 });
  }
}
Acción requerida:
Integrar el sistema de pagos utilizando los códigos y la estructura que he proporcionado.

Integrar la autenticación con Wallet, asegurando que los usuarios se autentiquen de forma segura.

Integrar la verificación de usuarios, asegurando que solo los humanos verificados puedan realizar ciertas acciones dentro de la app.

Mi dirección de wallet es:
0x01a0eea37c87cfaf13efd17674d2af21e5401bb0

Espero que puedan ayudarme con la implementación de estos tres sistemas en la mini app. Si necesitan más detalles o ajustes adicionales, por favor avísenme.